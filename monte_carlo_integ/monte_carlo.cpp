#include "MonteCarlo.decl.h" // this will be generated by charmc
#include <chrono>
#include <cstdlib>

/*readonly*/ CProxy_Main mainProxy;
constexpr int nElem = 1;

/*mainchare*/
class Main : public CBase_Main
{
    public:
        Main(CkArgMsg*)
        {
            // Start computation
            CkPrintf("Runnin Monte-Carlo integration on %d processors with %d elements.\n", CkNumPes(), nElem);
            CProxy_MCCElement pelements = CProxy_MCCElement::ckNew(nElem); // Create a new chare array with nElem elements
            mainProxy = thisProxy;
            // This is the entry method where
            // parallel, asynchronous computing starts
            // This method calls its counterparts
            // in other chares
            // instead of passing the parcel, entry methods could also have 
            // been called here, withing a loop
            

            dx_subdomain = (x_domain_max - x_domain_min)/nElem;
            
            ckout << " The main subdomain width is " << dx_subdomain << endl;

            Npersubdomain = int(Ntotal/nElem);
            
            ckout << "The number of iterations per subdomain is " << Npersubdomain << endl;

            
            for (int index=0; index<nElem-1; index++)
            {
                ckout << "Calling MC integrate on element "<< index << endl;
                x_subdomain_min = index*dx_subdomain;
                x_subdomain_max = (index+1)*dx_subdomain;

                pelements[index].MCIntegrate(Npersubdomain, 
                                             x_subdomain_min, 
                                             x_subdomain_max, 
                                             y_domain_min, 
                                             y_domain_max
                                             ); 
                // One already runs from the main / master chare ?
                
            }
            
            Nlast = Ntotal - Npersubdomain*(nElem-1);
            ckout << "The number of iterations in the last subdomain is " << Nlast << endl;
            x_subdomain_min = (nElem-1)*dx_subdomain;
            
            x_subdomain_max = x_domain_max - x_subdomain_min;
            ckout << "The boundaries of the final subdomain are xmain:" << x_subdomain_min << " xmax " << x_subdomain_max << endl;

            pelements[nElem-1].MCIntegrate(Nlast, 
                                           x_subdomain_min, 
                                           x_subdomain_max,
                                           y_domain_min,
                                           y_domain_max
                                           );

        };
        
        void done(double total_area)
        {
            // Area = total_area;

            // Finish computation
            //
            CkPrintf("The total area is %lf\n", total_area);
            CkPrintf("All done.\n");
            CkExit();
        };

    private:
        int Ntotal=100000;
        float x_domain_min=0, x_domain_max=1, x_subdomain_min, x_subdomain_max;
        float y_domain_min=0;
        float y_domain_max=10;
        float dx_subdomain;
        int Npersubdomain;
        int Nlast;
};



/*array [1D]*/
class MCCElement : public CBase_MCCElement
{
    public:
        MCCElement() 
        {
            srand(CkMyPe());
            ckout << "The rand seed is " << CkMyPe();

        } // Empty constrctor

        void MonteCarloStep(float x_subdomain_min, 
                            float x_subdomain_max, 
                            float y_subdomain_min, 
                            float y_subdomain_max)
        // Step integrator
        {
            ckout << "At area count " << local_area_counter << " on element " << CkMyPe() << " and processor " << thisIndex << endl;

            float rand_num_x, rand_num_y;

            rand_num_x = rand();
            rand_num_y = rand();
            
            rand_num_x = x_subdomain_min + (rand_num_x/RAND_MAX)*(x_subdomain_max - x_subdomain_min);
            rand_num_y = y_subdomain_min + (rand_num_y/RAND_MAX)*(y_subdomain_max - y_subdomain_min);

            float fun_val;

            fun_val = integrand(rand_num_x);

            if (rand_num_y<fun_val)
            {
                local_area_counter++;
            }

            else
            {
                ckout << "Missed a point " << endl;
            }
        }        

        float integrand(float x)
        // The integrand function
        {
            return 5;
        }

        void  MCIntegrate(int Npersubdomain, 
                          float x_subdomain_min, 
                          float x_subdomain_max, 
                          float y_subdomain_min, 
                          float y_subdomain_max
                          )
        // The MC integrator
        {
            while (local_counter<Npersubdomain)
            {
                MonteCarloStep(x_subdomain_min, 
                               x_subdomain_max, 
                               y_subdomain_min, 
                               y_subdomain_max
                               );

                local_counter++;
            }

        CkCallback cb(CkReductionTarget(Main, done), mainProxy);

        subdomain_area = (x_subdomain_max - x_subdomain_min)* (y_subdomain_max - y_subdomain_min);

        subdomain_integral = (double(local_area_counter)/double(Npersubdomain))*subdomain_area;

        ckout << "Subdomain area is " << subdomain_area << endl;
        ckout << "Subdomain integral is " << subdomain_integral << endl;

        contribute(sizeof(double), &subdomain_area, CkReduction::sum_double, cb);
        }

    private:
        int local_area_counter = 0;
        int local_counter = 0;
        float x_domain_max = 1;
        float x_domain_min = 0;
        float y_domain_max = 10;
        float y_domain_main = 0;
        float x_subdomain_min, x_subdomain_max;
        double subdomain_area = 0;
        double subdomain_integral=0;
};

#include "MonteCarlo.def.h" // created from MonteCarlo.ci file above
