#include "monte_carlo.decl.h" // this will be generated by charmc
#include <chrono>
#include <cstdlib>

/*readonly*/ CProxy_Main mainProxy;
constexpr int nElem = 8;

/*mainchare*/
class Main : public CBase_Main
{
    public:
        Main(CkArgMsg* m)
        {
            // Start computation
            CkPrintf("Runnin Monte-Carlo integration on %d processors with %d elements.\n", CkNumPes(), nElem);
            CProxy_MonteCarlo pelements = CProxy_MonteCarlo::ckNew(nElem); // Create a new chare array with nElem elements
            mainProxy = thisProxy;
            // This is the entry method where
            // parallel, asynchronous computing starts
            // This method calls its counterparts
            // in other chares
            // instead of passing the parcel, entry methods could also have 
            // been called here, withing a loop
            

            dx_subdomain = (x_domain_max - x_domain_min)/nElem;
            
            Npersubdomain = int(Ntotal/nElem);

            for(index=0; index<nElem-1; index++)
            {
                x_subdomain_min = index*dx_sub_domain;
                x_subdomain_max = (index+1)*dx_subdomain;

                result_arr[index] = arr[index].MCIntegrate(Npersubdomain, x_subdomain_min, x_subdomain_max); // One already runs from the main / master chare ?
                
            }
            
            Nlast = Ntotal - Npersubdomain*(nElem-1);
            x_subdomain_min = (nElem-1)*dx_subdomain;
            x_subdomain_max = x_domain_max - x_subdomain_min;
            result_arr[nElem-1] = arr[nElem-1].MCIntegrate(Nlast, x_subdomain_min, x_subdomain_max);

            for(index=0; index<nElem; index++)
            {
                Area+=result_arr[index];
            }

            CkPrintf("The integral value is %lf\n", Area);

        };
        
        thisProxy.done();

        void done()
        {
            // Finish computation
            CkPrintf("All done.\n");
            CkExit();
        };

    private:
        int Ntotal;
        float x_domain_min, x_domain_max;
        float dx_subdomain;
        int Npersubdomain;
        int result_arr[nElem];
        int Nlast;
        float Area=0;
};



/*array [1D]*/
class MonteCarlo : public CBase_MonteCarlo
{
    public:
        MonteCarlo() {} // Empty constrctor

        void MonteCarloStep(int* local_count)
        // Step integrator
        {
            float rand_num_x, rand_num_y;

            rand_num_x = rand();
            rand_num_y = rand();
            
            float fun_val;
            fun_val = integrand(rand_num_x);

            if (y<fun_val)
            {
                local_count++;
            }

        }

        float integrand(float x)
        // The integrand function
        {
            return 5;
        }

        float  MCIntegrate(int Npersubdomain, float x_subdomain_min, float x_subdomain_max)
        // The MC integrator
        {
            while (loa)


            
        }
    private:
        int* local_counter = 0;
        int* total_local_counts = 100;
        float x_domain_max = 10;
        float x_domain_min = -10;
        float y_domain_max = 100;
        float y_domain_main = -100;
        float x_subdomain_min, x_subdomain_max;
};

#include "MonteCarlo.def.h" // created from MonteCarlo.ci file above
